% close;
clear;
clc;

%% Initialise the problem data structure

optimalDesignFlag = false;

problem = Initialize.fnInitMethod('trapezoid');
problem = Initialize.fnInitVehicle(problem);
problem = Initialize.fnInitTrackv2(problem, true, false);
problem = Initialize.fnInitFunctionHandles(problem);
problem = Initialize.fnInitBounds(problem,optimalDesignFlag);

problem.options.optimalDesignFlag = optimalDesignFlag; 

%% Get initial estimate
% You need an initial guess for solving the BVP

problem = PreProcessing.fnGetInitialEstimate(problem, 'Load');

%% Set solver options and solve the Minimum Time Maneuvre 

options = optimoptions('fmincon', 'Display', 'iter-detailed', ...
        'useparallel', true, ...
        'StepTolerance', 1e-5, ...
        'ConstraintTolerance', 1e-5, ...
        'OptimalityTolerance', 1e-5, ...
        'SpecifyConstraintGradient', false, ...
        'SpecifyObjectiveGradient', false, ...
        'MaxIterations', 1e4, ...
        'MaxFunctionEvaluations', 1e8, ...
        'FiniteDifferenceType','forward',...
        'FiniteDifferenceStepSize', 1e-5, ...
        'Algorithm','interior-point',...
        'ScaleProblem',true,...
        "SubproblemAlgorithm","cg",...
        'PlotFcn', 'optimplotfvalconstr');
% 
% options = optimoptions('fmincon', 'Display', 'iter-detailed', ...
%         'useparallel', true, ...
%         'StepTolerance', 1e-5, ...
%         'ConstraintTolerance', 1e-5, ...
%         'OptimalityTolerance', 1e-5, ...
%         'SpecifyConstraintGradient', false, ...
%         'SpecifyObjectiveGradient', false, ...
%         'MaxIterations', 1e4, ...
%         'MaxFunctionEvaluations', 1e8, ...
%         'FiniteDifferenceType','forward',...
%         'FiniteDifferenceStepSize', 1e-5, ...
%         'Algorithm','interior-point',...
%         'ScaleProblem',true,...
%         "EnableFeasibilityMode",true,...
%         'PlotFcn', 'optimplotfvalconstr');
    
problem.options.nlpOpt = options;    

% Calls function that solves the NPL problem related to the MTM
soln = Solver.MTM(problem);

x_star = soln.grid.state;
u_star = soln.grid.control;
p_star = soln.grid.design;

Vehicle = problem.dsSystem.vd;
Track = problem.dsSystem.td;

%% getting additional outputs from optimal solution


[~,~,~,O] = fnDynamicsVehicle([],x_star(3:end,:),u_star,Vehicle,p_star);


KPIs = metrics_output(O,problem,soln);

ploting_script